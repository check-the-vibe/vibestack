"""Codex MCP configuration helpers."""
from __future__ import annotations

import argparse
import json
import os
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, Iterable, List, Optional


@dataclass
class MCPServerConfig:
    """Serializable representation of an MCP server entry."""

    command: str
    args: List[str] = field(default_factory=list)
    env: Dict[str, str] = field(default_factory=dict)
    startup_timeout_sec: Optional[float] = None
    tool_timeout_sec: Optional[float] = None

    def to_state(self) -> Dict[str, object]:
        state: Dict[str, object] = {
            "command": self.command,
            "args": list(self.args),
            "env": dict(self.env),
        }
        if self.startup_timeout_sec is not None:
            state["startup_timeout_sec"] = self.startup_timeout_sec
        if self.tool_timeout_sec is not None:
            state["tool_timeout_sec"] = self.tool_timeout_sec
        return state

    @classmethod
    def from_state(cls, payload: Dict[str, object]) -> "MCPServerConfig":
        return cls(
            command=str(payload.get("command", "")),
            args=[str(item) for item in payload.get("args", [])],
            env={str(k): str(v) for k, v in (payload.get("env") or {}).items()},
            startup_timeout_sec=_coerce_optional_float(payload.get("startup_timeout_sec")),
            tool_timeout_sec=_coerce_optional_float(payload.get("tool_timeout_sec")),
        )


class CodexConfigManager:
    """Creates and mutates Codex `config.toml` files inside a workspace."""

    STATE_FILE = "mcp_servers.json"
    CONFIG_FILE = "config.toml"
    HEADER_COMMENT = (
        "# Auto-generated by vibestack.sessions.codex_config\n"
        "# Use `python -m vibestack.sessions.codex_config` to make changes.\n"
    )

    def __init__(self, codex_home: Path | str | None = None) -> None:
        resolved_home = Path(
            codex_home or os.environ.get("CODEX_HOME") or Path.home() / ".codex"
        )
        self.codex_home = resolved_home
        self.codex_home.mkdir(parents=True, exist_ok=True)
        self._state_path = self.codex_home / self.STATE_FILE
        self._config_path = self.codex_home / self.CONFIG_FILE

    @property
    def config_path(self) -> Path:
        return self._config_path

    def load_state(self) -> Dict[str, Dict[str, object]]:
        if self._state_path.exists():
            payload = json.loads(self._state_path.read_text(encoding="utf-8"))
            servers = payload.get("servers", {})
        else:
            servers = {}
        normalized: Dict[str, Dict[str, object]] = {}
        for name, entry in servers.items():
            config = MCPServerConfig.from_state(entry)
            normalized[name] = config.to_state()
        return normalized

    def save_state(self, servers: Dict[str, Dict[str, object]]) -> None:
        payload = {"servers": {name: data for name, data in sorted(servers.items())}}
        self._state_path.write_text(
            json.dumps(payload, indent=2, sort_keys=True) + "\n",
            encoding="utf-8",
        )
        self._config_path.write_text(self._render_config(payload["servers"]), encoding="utf-8")

    def ensure_server(self, name: str, config: MCPServerConfig) -> None:
        servers = self.load_state()
        desired = config.to_state()
        current = servers.get(name)
        if current != desired:
            servers[name] = desired
            self.save_state(servers)

    def remove_server(self, name: str) -> bool:
        servers = self.load_state()
        if name not in servers:
            return False
        servers.pop(name)
        self.save_state(servers)
        return True

    def list_servers(self) -> Dict[str, Dict[str, object]]:
        return self.load_state()

    def ensure_default_playwright(self, *, browser: str = "chromium") -> None:
        launch_args = ["@playwright/mcp@latest", "--browser", browser]
        config = MCPServerConfig(command="npx", args=launch_args)
        self.ensure_server("playwright", config)

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------
    def _render_config(self, servers: Dict[str, Dict[str, object]]) -> str:
        lines: List[str] = [self.HEADER_COMMENT.rstrip(), ""]
        if not servers:
            lines.append("# No MCP servers configured.\n")
        for name in sorted(servers):
            entry = servers[name]
            lines.append(f"[mcp_servers.{name}]")
            lines.append(f"command = {self._to_toml_string(entry['command'])}")
            args = entry.get("args") or []
            args_literal = ", ".join(self._to_toml_string(str(arg)) for arg in args)
            lines.append(f"args = [{args_literal}]")
            startup_timeout = entry.get("startup_timeout_sec")
            if startup_timeout is not None:
                lines.append(f"startup_timeout_sec = {startup_timeout}")
            tool_timeout = entry.get("tool_timeout_sec")
            if tool_timeout is not None:
                lines.append(f"tool_timeout_sec = {tool_timeout}")
            env = entry.get("env") or {}
            if env:
                lines.append(f"[mcp_servers.{name}.env]")
                for key in sorted(env):
                    lines.append(f"{key} = {self._to_toml_string(str(env[key]))}")
            lines.append("")
        return "\n".join(lines).rstrip() + "\n"

    @staticmethod
    def _to_toml_string(value: str) -> str:
        escaped = value.replace("\\", "\\\\").replace("\"", "\\\"")
        return f'"{escaped}"'


def _coerce_optional_float(value: object) -> Optional[float]:
    if value is None:
        return None
    try:
        return float(value)
    except (TypeError, ValueError):
        return None


def _parse_env_entries(entries: Iterable[str]) -> Dict[str, str]:
    env: Dict[str, str] = {}
    for item in entries:
        if "=" not in item:
            raise ValueError(f"Environment mapping '{item}' must be KEY=VALUE")
        key, value = item.split("=", 1)
        env[key] = value
    return env


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Manage Codex MCP config entries")
    parser.add_argument(
        "--home",
        dest="codex_home",
        help="Override CODEX_HOME (defaults to $CODEX_HOME or ~/.codex)",
    )
    subparsers = parser.add_subparsers(dest="command", required=True)

    ensure_parser = subparsers.add_parser(
        "ensure-defaults",
        help="Create config.toml and ensure built-in presets such as Playwright",
    )
    ensure_parser.add_argument(
        "--playwright-browser",
        default="chromium",
        help="Browser channel passed to @playwright/mcp (default: chromium)",
    )

    add_parser = subparsers.add_parser("add", help="Add or update an MCP server entry")
    add_parser.add_argument("name", help="Server name used in config.toml")
    add_parser.add_argument(
        "--env",
        action="append",
        default=[],
        help="Environment variables in KEY=VALUE form (repeat for multiple)",
    )
    add_parser.add_argument(
        "--startup-timeout",
        type=float,
        help="Custom startup timeout override in seconds",
    )
    add_parser.add_argument(
        "--tool-timeout",
        type=float,
        help="Custom per-tool timeout override in seconds",
    )
    add_parser.add_argument(
        "launcher",
        nargs=argparse.REMAINDER,
        help="Command to launch the MCP server (prefix with -- to end option parsing)",
    )

    list_parser = subparsers.add_parser("list", help="List configured MCP servers")
    list_parser.add_argument(
        "--json",
        action="store_true",
        help="Emit JSON instead of a human-readable table",
    )

    remove_parser = subparsers.add_parser("remove", help="Remove an MCP server entry")
    remove_parser.add_argument("name", help="Server name to delete")

    return parser


def main(argv: Optional[List[str]] = None) -> int:
    parser = _build_parser()
    args = parser.parse_args(argv)

    manager = CodexConfigManager(codex_home=args.codex_home)

    if args.command == "ensure-defaults":
        manager.ensure_default_playwright(browser=args.playwright_browser)
        return 0

    if args.command == "add":
        try:
            env = _parse_env_entries(args.env)
        except ValueError as exc:
            parser.error(str(exc))
        launcher = list(args.launcher or [])
        if launcher and launcher[0] == "--":
            launcher = launcher[1:]
        if not launcher:
            parser.error("Provide a launcher command after '--'")
        command, *command_args = launcher
        config = MCPServerConfig(
            command=command,
            args=command_args,
            env=env,
            startup_timeout_sec=args.startup_timeout,
            tool_timeout_sec=args.tool_timeout,
        )
        manager.ensure_server(args.name, config)
        return 0

    if args.command == "list":
        servers = manager.list_servers()
        if args.json:
            print(json.dumps(servers, indent=2, sort_keys=True))
            return 0
        if not servers:
            print("No MCP servers configured")
            return 0
        header = f"{'NAME':<20} {'COMMAND':<10} ARGS"
        print(header)
        print("-" * len(header))
        for name, entry in sorted(servers.items()):
            args_literal = " ".join(str(arg) for arg in entry.get("args") or [])
            print(f"{name:<20} {entry['command']:<10} {args_literal}")
        return 0

    if args.command == "remove":
        removed = manager.remove_server(args.name)
        if not removed:
            parser.error(f"Server '{args.name}' not configured")
        return 0

    parser.error("Unknown command")
    return 1


if __name__ == "__main__":  # pragma: no cover - CLI entrypoint
    sys.exit(main())
